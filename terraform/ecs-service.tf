# The service, task, and associated helper resources for the web-app ecs service

#
# Networking to ECS service
#

# load balancer, forwards data to hello-world ecs tasks
resource "aws_lb" "main" {
    name               = "${local.name}-alb"
    internal           = false
    load_balancer_type = "application"
    security_groups    = [aws_security_group.container.id, module.vpc.default_security_group_id]
    subnets            = module.vpc.public_subnets
    enable_cross_zone_load_balancing = "true"
}

# Target group, to be associated with the hello-world ecs task
resource "aws_lb_target_group" "main" {
  name     = "${local.name}-lb-tg"
  port     = 80
  protocol = "HTTP"
  target_type = "ip"
  vpc_id   = module.vpc.vpc_id
  depends_on = [ aws_lb.main ]
}

# Attach the aws_lb and the ecs task through a listener
resource "aws_lb_listener" "main" {
   load_balancer_arn    = aws_lb.main.id
   port                 = "80"
   protocol             = "HTTP"
   default_action {
    target_group_arn = aws_lb_target_group.main.id
    type             = "forward"
  }
}

# allow internet connections on port 80 to the alb
# This gets routed to port 5000 on the task, as configured by
# the ecs-alb-service-task module
resource "aws_security_group" "container" {
  name        = "${local.name}-allow-tls" # I should change this name . . .
  description = "Allow TLS inbound traffic"
  vpc_id      = module.vpc.vpc_id

  ingress {
    description      = "Ingress to ecs"
    from_port        = 80
    to_port          = 80
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }

  tags = {
    Name = local.name
  }
}

#
# ECS Service
#

module "ecs-container-definition" {
  source  = "cloudposse/ecs-container-definition/aws"
  version = "0.58.1"
  container_name               = local.name
  container_image              = "${aws_ecr_repository.main.repository_url}:latest"
  container_memory             = 300
  container_cpu                = 1000
  essential                    = true
  port_mappings                = [
    {
      containerPort = 5000
      hostPort = 5000
      protocol = "tcp"
    }
  ]
}

module "ecs-alb-service-task" {
  source  = "cloudposse/ecs-alb-service-task/aws"
  version = "0.66.2"
  name = local.name
  alb_security_group                 = module.vpc.default_security_group_id
  container_definition_json          = module.ecs-container-definition.json_map_encoded_list
  ecs_cluster_arn                    = module.ecs.cluster_arn
  launch_type                        = "EC2"
  vpc_id                             = module.vpc.vpc_id
  security_group_ids                 = [module.vpc.default_security_group_id]
  subnet_ids                         = module.vpc.private_subnets
  ignore_changes_task_definition     = false
  # Ensure updates leave at least 50% capacity online during a deployment
  deployment_minimum_healthy_percent = 50
  # Allow up to double the desired tasks to run during a deployment
  deployment_maximum_percent         = 200
  # Keeping costs minimal at first, we can scale this along with the number of available nodes
  desired_count                      = 2
  task_memory                        = 300
  task_cpu                           = 1000
  task_exec_policy_arns = [aws_iam_policy.main.arn]
  ecs_load_balancers = [
    {
      container_name = local.name
      # gunicorn listens on port 5000. Send directly to port 5000, since client connections must
      # pass through the alb
      container_port = 5000
      elb_name="${local.name}-alb"
      target_group_arn = aws_lb_target_group.main.arn
    }
  ]
}

# ECR repo, the image must be uploaded separately
resource "aws_ecr_repository" "main" {
  name                 = local.name
}


resource "aws_iam_role" "main" {
 name = "${local.name}-ecs-iam-role"

 assume_role_policy = jsonencode({
   "Version" : "2012-10-17",
   "Statement" : [
     {
       "Effect" : "Allow",
       "Principal" : {
         "Service" : "ecs-tasks.amazonaws.com"
       },
       "Action" : "sts:AssumeRole"
     }
   ]
  })
}

# Associate the task exec role (generated by ecs-aln-service-task) with
# the iam polict that grants dynamodb access
resource "aws_iam_role_policy_attachment" "main" {
   role = module.ecs-alb-service-task.task_role_name
   policy_arn = aws_iam_policy.main.arn
}

# Grant the web app task full access to the dtynamodb table. This can
# probably be paired down, but the permissions were left broad because
# the data is non-sensitive and the app use case might expand
resource "aws_iam_policy" "main" {
   name = "dynamodb_ecs_policy"
   policy = jsonencode({
      "Version" : "2012-10-17",
      "Statement" : [
        {
           "Effect" : "Allow",
           "Action" : ["dynamodb:*"],
           "Resource" : aws_dynamodb_table.main.arn
        }
      ]
   })
}
